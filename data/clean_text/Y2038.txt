the year  problem also known as y yk yk superbug or the epochalypse is a time computing problem that leaves some computer systems unable to represent times after  utc on  january  the problem exists in systems which measure unix timethe number of seconds elapsed since the unix epoch  utc on  january and store it in a signed bit integer the data type is only capable of representing integers between  and    meaning the latest time that can be properly encoded is    seconds after epoch  utc on  january  attempting to increment to the following second  will cause the integer to overflow setting its value to  which systems will interpret as  seconds before epoch  utc on  december  systems using unsigned bit integers will overflow in  the problem resembles the year  problem but arises from limitations in base binary time representation rather than base computer systems that use time for critical computations may encounter fatal errors if the year  problem is not addressed some applications that use future dates have already encountered the bug the most vulnerable systems are those which are infrequently or never updated such as legacy and embedded systems modern systems and software updates to legacy systems address this problem by using signed bit integers instead of bit integers which will take  billion years to overflowapproximately  times the estimated age of the universe cause many computer systems measure time and date using unix time an international standard for digital timekeeping unix time is defined as the number of seconds elapsed ignoring leap seconds since  utc on  january  known as the unix epoch unix time has historically been encoded as a signed bit integer a data type composed of  binary digits bits which represent an integer value with signed meaning that the number can represent both positive and negative numbers as well as zero and is usually stored in twos complement format thus a signed bit integer can only represent integer values from  to    inclusive consequently if a signed bit integer is used to store unix time the latest time that can be stored is     seconds after epoch which is  utc on  january  systems that attempt to increment this value by one more second to  seconds after epoch  will suffer integer overflow inadvertently flipping the sign bit to indicate a negative number this changes the integer value to  or  seconds before epoch rather than after which systems will interpret as  utc on  december  from here systems will continue to count up toward zero and then up through the positive integers again as many computer systems use time computations to run critical functions the bug may introduce serious problems vulnerable systems any system using data structures with signed bit time representations has an inherent risk of failing a full list of these data structures is virtually impossible to derive but there are wellknown data structures that have the unix time problem file systems that use  bits to represent times in inodes such as ext ext and reiserfs databases with bit time fields database query languages such as sql that have unixtimestamplike commands many bit android devices on android  or earlier including zte blade google nexus  and  toshiba android tablets os xera powerpc macs will have their system clock get stuck on the rollover time as of mac os x tiger bit ios devices as of iphone  on circa ios  will be unable to unlock or to consistently enter charging mode and the lockscreen clock will not show up as of circa windows  version h if an x bit device has not been turned on at the rollover point but is started up after the rollover the system clock skips ahead to april   and the date options in windows s main settings menu does not show any selectable numbers software built with visual studio has the gmtime format which serves as a mapping of timets bit version roll over at  january   software built with pre versions of visual studio were known to have gmtime correspond to gmtime and the correspondence can be forced when building with bit versions of visual studio through visual studio  by specifying usebittimet embedded systems embedded systems that use dates for either computation or diagnostic logging are most likely to be affected by the y problem despite the modern  month generational update in computer systems technology embedded systems are designed to last the lifetime of the machine in which they are a component it is conceivable that some of these systems may still be in use in  it may be difficult or in some cases impossible to upgrade the software running these systems ultimately requiring replacement if the bit limitations are to be corrected many transportation systems from flight to automobiles use embedded systems extensively in automotive systems this may include antilock braking system abs electronic stability control escesp traction control tcs and automatic fourwheel drive aircraft may use inertial guidance systems and gps receivers another major use of embedded systems is in communications devices including cell phones and internetenabled appliances eg routers wireless access points ip cameras which rely on storing an accurate time and date and are increasingly based on unixlike operating systems however this does not imply that all embedded systems will suffer from the y problem since many such systems do not require access to dates for those that do those systems which only track the difference between timesdates and not absolute timesdates will by the nature of the calculation not experience a major problem this is the case for automotive diagnostics based on legislated standards such as carb california air resources board early problems in may  reports surfaced of an early manifestation of the y problem in the aolserver software the software was designed with a kludge to handle a database request that should never time out rather than specifically handling this special case the initial design simply specified an arbitrary timeout date in the future with a default configuration specifying that requests should time out after a maximum of one billion seconds however one billion seconds before the  cutoff date is  utc on  may  so requests sent after this time would result in a timeout date which is beyond the cutoff this made timeout calculations overflow and return dates that were actually in the past causing software to crash when the problem was discovered aolserver operators had to edit the configuration file and set the timeout to a lower value many types of selfsigned ca certificates generated on bit systems can have very long expiration dates that go beyond the rollover point which will make them not work correctly affecting https verifications on services for instance vpns and sites that use them the ms filtering engine update antimalware functions of microsoft exchange server installations broke on january   after an update the functions mapped the processed updateversion numbers which used a  or digit yymmddn format to the unix time stamp numbers despite their times being very different so when the engine received the   v update which it took to mean  with an extra zero near the end it tried mapping it to the bit unix times number and failed due to being higher than  affected exchange servers failed to work unless they turned off the antimalware functions and an automated fix was published on january   in oracle access management version  for windows the identity console component sets a cookie containing ui preferences with an expiry of  seconds in the future approximately  years  days this is beyond  january  and so it throws an exception for certain search activities after  utc on  march  because the gmtimer call cannot convert the number provided to a date to write to the cookie solutions there is no universal solution for the year  problem for example in the c language any change to the definition of the timet data type would result in codecompatibility problems in any application in which date and time representations are dependent on the nature of the signed bit timet integer changing timet to an unsigned bit integer which would extend the range to  specifically  utc on sunday  february  would adversely affect programs that store retrieve or manipulate dates prior to  as such dates are represented by negative numbers increasing the size of the timet type to  bits in an existing system would cause incompatible changes to the layout of structures and the binary interface of functions most operating systems designed to run on bit hardware already use signed bit timet integers using a signed bit value introduces a new wraparound date that is over twenty times greater than the estimated age of the universe approximately  billion years from now the ability to make computations on dates is limited by the fact that tmyear uses a signed bit integer value starting at  for the year this limits the year to a maximum of     alternative proposals have been made some of which are already in use such as storing either milliseconds or microseconds since an epoch typically either  january  or  january  in a signed bit integer providing a minimum range of  years at microsecond resolution in particular javas and javascripts use of bit signed integers to represent absolute timestamps as milliseconds since  january  will work correctly for the next  million years other proposals for new time representations provide different precisions ranges and sizes almost always wider than  bits as well as solving other related problems such as the handling of leap seconds in particular tai is an implementation of the international atomic time tai standard the current international realtime standard for defining a second and frame of reference implemented solutions starting with ruby version  released on  august  the bug with year  is fixed by storing time in a signed bit integer on systems with bit timet starting with netbsd version  released in october  the netbsd operating system uses a bit timet for both bit and bit architectures applications that were compiled for an older netbsd release with bit timet are supported via a binary compatibility layer but such older applications will still suffer from the y problem openbsd since version  released in may  also uses a bit timet for both bit and bit architectures in contrast to netbsd there is no binary compatibility layer therefore applications expecting a bit timet and applications using anything different from timet to store time values may break linux originally used a bit timet for bit architectures only the pure bit abi was not changed due to backward compatibility starting with version  of  bit timet is supported on bit architectures too this was done primarily for the sake of embedded linux systems gnu c library since version  released august  added support for using bit timet on bit platforms with appropriate linux versions this support can be activated by defining preprocessor macro timebits to  when compiling source code freebsd uses bit timet for all bit and bit architectures except bit i which uses signed bit timet instead the x abi for linux which defines an environment for programs with bit addresses but running the processor in bit mode uses a bit timet since it was a new environment there was no need for special compatibility precautions network file system version  has defined its time fields as struct nfstime intt seconds uintt nseconds since december  version  supports unsigned bit values as struct nfstime uint seconds uint nseconds values greater than zero for the seconds field denote dates after the hour january   values less than zero for the seconds field denote dates before the hour january   in both cases the nseconds nanoseconds field is to be added to the seconds field for the final time representation the ext filesystem when used with inode sizes larger than  bytes has an extra bit field per timestamp of which  bits are used for the nanoseconds part of the timestamp and the other  bits are used to extend the timestamp range to the year  the xfs filesystem starting with linux  has an optional big timestamps feature which extends the timestamp range to the year  while the native apis of openvms can support timestamps up to  july  the c runtime library crtl uses bit integers for timet as part of yk compliance work that was carried out in  the crtl was modified to use unsigned bit integers to represent time extending the range of timet up to  february  as of mysql  released in january  the functions fromunixtime unixtimestamp and converttz handle bit values on platforms that support them this includes bit versions of linux macos and windows in older versions builtin functions like unixtimestamp will return  after  utc on  january  as of mariadb  released in may  the data type timestamp and functions fromunixtime unixtimestamp and converttz handle unsigned bit values on bit versions of linux macos and windows this extended the range to   and allowed users to store such timestamp values in tables without changing the storage layout and thus staying fully compatible with existing user data starting with visual c  the crt uses a bit timet unless the usebittimet preprocessor macro is defined however the windows api itself is unaffected by the year  bug as windows internally tracks time as the number of nanosecond intervals since  january  in a bit signed integer which will not overflow until year  the os x rollover stuck system clock bug had been fixed as of mac os x el capitan dosboxx removed a dependency on the intxto macro for time calculation in version  for windows devices whose clocks have jumped ahead a number of software tools to edit system settings or to sync with time servers exist that can mitigate any effects microsofts syntax guides for visual studio have discouraged the use of usebittimet and it has not been allowed when building with bit versions of visual studio despite the age of the oracle access manager version in question  june  oracle issued the patch  on  april  newer versions of oracle access manager are not known to be affected by the problem see also time formatting and storage bugs lists other similar problems often caused by rollover similar to the cause of this year  problem a gps week number rollover will coincidentally happen later in  but for a different reason a rollover in network time protocol version  and earlier in  is very similar to the  problem but is not identical notes references external links y proofness design glibc wiki entry in how stuff works the project  frequently asked questions critical and significant dates  archived  november  at the wayback machine a safe replacement for timeh on  bit systems solving the year  problem in the linux kernel baraniuk chris  may  the number glitch that can lead to catastrophe bbc future clewett james   the end of time unix numberphile brady haran archived from the original on  may  retrieved  april